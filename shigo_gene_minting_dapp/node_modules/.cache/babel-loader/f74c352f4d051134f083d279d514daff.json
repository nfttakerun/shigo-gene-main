{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/takerun/Documents/shigo-gene-main/shigo_gene_minting_dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/takerun/Documents/shigo-gene-main/shigo_gene_minting_dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/takerun/Documents/shigo-gene-main/shigo_gene_minting_dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/takerun/Documents/shigo-gene-main/shigo_gene_minting_dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/takerun/Documents/shigo-gene-main/shigo_gene_minting_dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/takerun/Documents/shigo-gene-main/shigo_gene_minting_dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/takerun/Documents/shigo-gene-main/shigo_gene_minting_dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleMountainRange = void 0;\n\nvar buffer_1 = require(\"buffer\");\n\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n\nvar Base_1 = __importDefault(require(\"./Base\")); // @credit: https://github.com/wanseob/solidity-mmr\n\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\n\n\nvar MerkleMountainRange = /*#__PURE__*/function (_Base_1$default) {\n  _inherits(MerkleMountainRange, _Base_1$default);\n\n  var _super = _createSuper(MerkleMountainRange);\n\n  function MerkleMountainRange() {\n    var _this;\n\n    var hashFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : sha256_1.default;\n    var leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var hashLeafFn = arguments.length > 2 ? arguments[2] : undefined;\n    var peakBaggingFn = arguments.length > 3 ? arguments[3] : undefined;\n    var hashBranchFn = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, MerkleMountainRange);\n\n    _this = _super.call(this);\n    _this.root = buffer_1.Buffer.alloc(0);\n    _this.size = 0;\n    _this.width = 0;\n    _this.hashes = {};\n    _this.data = {};\n    leaves = leaves.map(_this.bufferify);\n    _this.hashFn = _this.bufferifyFn(hashFn);\n    _this.hashLeafFn = hashLeafFn;\n    _this.peakBaggingFn = peakBaggingFn;\n    _this.hashBranchFn = hashBranchFn;\n\n    var _iterator = _createForOfIteratorHelper(leaves),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var leaf = _step.value;\n\n        _this.append(leaf);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return _this;\n  }\n  /**\n   * @desc This only stores the hashed value of the leaf.\n   * If you need to retrieve the detail data later, use a map to store them.\n   */\n\n\n  _createClass(MerkleMountainRange, [{\n    key: \"append\",\n    value: function append(data) {\n      data = this.bufferify(data);\n      var dataHash = this.hashFn(data);\n      var dataHashHex = this.bufferToHex(dataHash);\n\n      if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n        this.data[dataHashHex] = data;\n      }\n\n      var leaf = this.hashLeaf(this.size + 1, dataHash);\n      this.hashes[this.size + 1] = leaf;\n      this.width += 1; // find peaks for enlarged tree\n\n      var peakIndexes = this.getPeakIndexes(this.width); // the right most peak's value is the new size of the updated tree\n\n      this.size = this.getSize(this.width); // starting from the left-most peak, get all peak hashes\n\n      var peaks = [];\n\n      for (var i = 0; i < peakIndexes.length; i++) {\n        peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n      } // update the tree root hash\n\n\n      this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n\n  }, {\n    key: \"hashLeaf\",\n    value: function hashLeaf(index, dataHash) {\n      dataHash = this.bufferify(dataHash);\n\n      if (this.hashLeafFn) {\n        return this.bufferify(this.hashLeafFn(index, dataHash));\n      }\n\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n\n  }, {\n    key: \"hashBranch\",\n    value: function hashBranch(index, left, right) {\n      if (this.hashBranchFn) {\n        return this.bufferify(this.hashBranchFn(index, left, right));\n      }\n\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n  }, {\n    key: \"getPeaks\",\n    value: function getPeaks() {\n      var peakIndexes = this.getPeakIndexes(this.width);\n      var peaks = [];\n\n      for (var i = 0; i < peakIndexes.length; i++) {\n        peaks[i] = this.hashes[peakIndexes[i]];\n      }\n\n      return peaks;\n    }\n  }, {\n    key: \"getLeafIndex\",\n    value: function getLeafIndex(width) {\n      if (width % 2 === 1) {\n        return this.getSize(width);\n      }\n\n      return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n\n  }, {\n    key: \"getPeakIndexes\",\n    value: function getPeakIndexes(width) {\n      var numPeaks = this.numOfPeaks(width);\n      var peakIndexes = [];\n      var count = 0;\n      var size = 0;\n\n      for (var i = 255; i > 0; i--) {\n        if ((width & 1 << i - 1) !== 0) {\n          // peak exists\n          size = size + (1 << i) - 1;\n          peakIndexes[count++] = size;\n\n          if (peakIndexes.length >= numPeaks) {\n            break;\n          }\n        }\n      }\n\n      if (count !== peakIndexes.length) {\n        throw new Error('invalid bit calculation');\n      }\n\n      return peakIndexes;\n    }\n  }, {\n    key: \"numOfPeaks\",\n    value: function numOfPeaks(width) {\n      var bits = width;\n      var num = 0;\n\n      while (bits > 0) {\n        if (bits % 2 === 1) {\n          num++;\n        }\n\n        bits = bits >> 1;\n      }\n\n      return num;\n    }\n  }, {\n    key: \"peakBagging\",\n    value: function peakBagging(width, peaks) {\n      var size = this.getSize(width);\n\n      if (this.numOfPeaks(width) !== peaks.length) {\n        throw new Error('received invalid number of peaks');\n      }\n\n      if (width === 0 && !peaks.length) {\n        return buffer_1.Buffer.alloc(0);\n      }\n\n      if (this.peakBaggingFn) {\n        return this.bufferify(this.peakBaggingFn(size, peaks));\n      }\n\n      return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size)].concat(_toConsumableArray(peaks.map(this.bufferify)))));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize(width) {\n      return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      return this.root;\n    }\n  }, {\n    key: \"getHexRoot\",\n    value: function getHexRoot() {\n      return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n\n  }, {\n    key: \"mountainHeight\",\n    value: function mountainHeight(size) {\n      var height = 1;\n\n      while (1 << height <= size + height) {\n        height++;\n      }\n\n      return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n\n  }, {\n    key: \"heightAt\",\n    value: function heightAt(index) {\n      var reducedIndex = index;\n      var peakIndex = 0;\n      var height = 0; // if an index has a left mountain then subtract the mountain\n\n      while (reducedIndex > peakIndex) {\n        reducedIndex -= (1 << height) - 1;\n        height = this.mountainHeight(reducedIndex);\n        peakIndex = (1 << height) - 1;\n      } // index is on the right slope\n\n\n      return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n\n  }, {\n    key: \"isLeaf\",\n    value: function isLeaf(index) {\n      return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(index) {\n      var left = index - (1 << this.heightAt(index) - 1);\n      var right = index - 1;\n\n      if (left === right) {\n        throw new Error('not a parent');\n      }\n\n      return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n\n  }, {\n    key: \"getMerkleProof\",\n    value: function getMerkleProof(index) {\n      if (index > this.size) {\n        throw new Error('out of range');\n      }\n\n      if (!this.isLeaf(index)) {\n        throw new Error('not a leaf');\n      }\n\n      var root = this.root;\n      var width = this.width; // find all peaks for bagging\n\n      var peaks = this.getPeakIndexes(this.width);\n      var peakBagging = [];\n      var cursor = 0;\n\n      for (var i = 0; i < peaks.length; i++) {\n        // collect the hash of all peaks\n        peakBagging[i] = this.hashes[peaks[i]]; // find the peak which includes the target index\n\n        if (peaks[i] >= index && cursor === 0) {\n          cursor = peaks[i];\n        }\n      }\n\n      var left = 0;\n      var right = 0; // get hashes of the siblings in the mountain which the index belgons to.\n      // it moves the cursor from the summit of the mountain down to the target index\n\n      var height = this.heightAt(cursor);\n      var siblings = [];\n\n      while (cursor !== index) {\n        height--;\n\n        var _this$getChildren = this.getChildren(cursor);\n\n        var _this$getChildren2 = _slicedToArray(_this$getChildren, 2);\n\n        left = _this$getChildren2[0];\n        right = _this$getChildren2[1];\n        // move the cursor down to the left size or right size\n        cursor = index <= left ? left : right; // remaining node is the sibling\n\n        siblings[height - 1] = this.hashes[index <= left ? right : left];\n      }\n\n      return {\n        root: root,\n        width: width,\n        peakBagging: peakBagging,\n        siblings: siblings\n      };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(root, width, index, value, peaks, siblings) {\n      value = this.bufferify(value);\n      var size = this.getSize(width);\n\n      if (size < index) {\n        throw new Error('index is out of range');\n      } // check the root equals the peak bagging hash\n\n\n      if (!root.equals(this.peakBagging(width, peaks))) {\n        throw new Error('invalid root hash from the peaks');\n      } // find the mountain where the target index belongs to\n\n\n      var cursor = 0;\n      var targetPeak;\n      var peakIndexes = this.getPeakIndexes(width);\n\n      for (var i = 0; i < peakIndexes.length; i++) {\n        if (peakIndexes[i] >= index) {\n          targetPeak = peaks[i];\n          cursor = peakIndexes[i];\n          break;\n        }\n      }\n\n      if (!targetPeak) {\n        throw new Error('target not found');\n      } // find the path climbing down\n\n\n      var height = siblings.length + 1;\n      var path = new Array(height);\n      var left = 0;\n      var right = 0;\n\n      while (height > 0) {\n        // record the current cursor and climb down\n        path[--height] = cursor;\n\n        if (cursor === index) {\n          // on the leaf node. Stop climbing down\n          break;\n        } else {\n          // on the parent node. Go left or right\n          var _this$getChildren3 = this.getChildren(cursor);\n\n          var _this$getChildren4 = _slicedToArray(_this$getChildren3, 2);\n\n          left = _this$getChildren4[0];\n          right = _this$getChildren4[1];\n          cursor = index > left ? right : left;\n          continue;\n        }\n      } // calculate the summit hash climbing up again\n\n\n      var node;\n\n      while (height < path.length) {\n        // move cursor\n        cursor = path[height];\n\n        if (height === 0) {\n          // cusor is on the leaf\n          node = this.hashLeaf(cursor, this.hashFn(value));\n        } else if (cursor - 1 === path[height - 1]) {\n          // cursor is on a parent and a siblings is on the left\n          node = this.hashBranch(cursor, siblings[height - 1], node);\n        } else {\n          // cursor is on a parent and a siblings is on the right\n          node = this.hashBranch(cursor, node, siblings[height - 1]);\n        } // climb up\n\n\n        height++;\n      } // computed hash value of the summit should equal to the target peak hash\n\n\n      if (!node.equals(targetPeak)) {\n        throw new Error('hashed peak is invalid');\n      }\n\n      return true;\n    }\n  }, {\n    key: \"peaksToPeakMap\",\n    value: function peaksToPeakMap(width, peaks) {\n      var peakMap = {};\n      var bitIndex = 0;\n      var peakRef = 0;\n      var count = peaks.length;\n\n      for (var height = 1; height <= 32; height++) {\n        // index starts from the right most bit\n        bitIndex = 32 - height;\n        peakRef = 1 << height - 1;\n\n        if ((width & peakRef) !== 0) {\n          peakMap[bitIndex] = peaks[--count];\n        } else {\n          peakMap[bitIndex] = 0;\n        }\n      }\n\n      if (count !== 0) {\n        throw new Error('invalid number of peaks');\n      }\n\n      return peakMap;\n    }\n  }, {\n    key: \"peakMapToPeaks\",\n    value: function peakMapToPeaks(width, peakMap) {\n      var arrLength = this.numOfPeaks(width);\n      var peaks = new Array(arrLength);\n      var count = 0;\n\n      for (var i = 0; i < 32; i++) {\n        if (peakMap[i] !== 0) {\n          peaks[count++] = peakMap[i];\n        }\n      }\n\n      if (count !== arrLength) {\n        throw new Error('invalid number of peaks');\n      }\n\n      return peaks;\n    }\n  }, {\n    key: \"peakUpdate\",\n    value: function peakUpdate(width, prevPeakMap, itemHash) {\n      var nextPeakMap = {};\n      var newWidth = width + 1;\n      var cursorIndex = this.getLeafIndex(newWidth);\n      var cursorNode = this.hashLeaf(cursorIndex, itemHash);\n      var bitIndex = 0;\n      var peakRef = 0;\n      var prevPeakExist = false;\n      var nextPeakExist = false;\n      var obtained = false;\n\n      for (var height = 1; height <= 32; height++) {\n        // index starts from the right most bit\n        bitIndex = 32 - height;\n\n        if (obtained) {\n          nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n        } else {\n          peakRef = 1 << height - 1;\n          prevPeakExist = (width & peakRef) !== 0;\n          nextPeakExist = (newWidth & peakRef) !== 0; // get new cursor node with hashing the peak and the current cursor\n\n          cursorIndex++;\n\n          if (prevPeakExist) {\n            cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n          } // if new peak exists for the bit index\n\n\n          if (nextPeakExist) {\n            // if prev peak exists for the bit index\n            if (prevPeakExist) {\n              nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            } else {\n              nextPeakMap[bitIndex] = cursorNode;\n            }\n\n            obtained = true;\n          } else {\n            nextPeakMap[bitIndex] = 0;\n          }\n        }\n      }\n\n      return nextPeakMap;\n    }\n  }, {\n    key: \"rollUp\",\n    value: function rollUp(root, width, peaks, itemHashes) {\n      // check the root equals the peak bagging hash\n      if (!root.equals(this.peakBagging(width, peaks))) {\n        throw new Error('invalid root hash from the peaks');\n      }\n\n      var tmpWidth = width;\n      var tmpPeakMap = this.peaksToPeakMap(width, peaks);\n\n      for (var i = 0; i < itemHashes.length; i++) {\n        tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n        tmpWidth++;\n      }\n\n      return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n\n  }, {\n    key: \"_getOrCreateNode\",\n    value: function _getOrCreateNode(index) {\n      if (index > this.size) {\n        throw new Error('out of range');\n      }\n\n      if (!this.hashes[index]) {\n        var _this$getChildren5 = this.getChildren(index),\n            _this$getChildren6 = _slicedToArray(_this$getChildren5, 2),\n            leftIndex = _this$getChildren6[0],\n            rightIndex = _this$getChildren6[1];\n\n        var leftHash = this._getOrCreateNode(leftIndex);\n\n        var rightHash = this._getOrCreateNode(rightIndex);\n\n        this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n      }\n\n      return this.hashes[index];\n    }\n  }]);\n\n  return MerkleMountainRange;\n}(Base_1.default);\n\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleMountainRange","buffer_1","require","sha256_1","Base_1","hashFn","default","leaves","hashLeafFn","peakBaggingFn","hashBranchFn","root","Buffer","alloc","size","width","hashes","data","map","bufferify","bufferifyFn","leaf","append","dataHash","dataHashHex","bufferToHex","hashLeaf","peakIndexes","getPeakIndexes","getSize","peaks","i","length","_getOrCreateNode","peakBagging","index","concat","left","right","numPeaks","numOfPeaks","count","Error","bits","num","getRoot","height","reducedIndex","peakIndex","mountainHeight","heightAt","isLeaf","cursor","siblings","getChildren","equals","targetPeak","path","Array","node","hashBranch","peakMap","bitIndex","peakRef","arrLength","prevPeakMap","itemHash","nextPeakMap","newWidth","cursorIndex","getLeafIndex","cursorNode","prevPeakExist","nextPeakExist","obtained","itemHashes","tmpWidth","tmpPeakMap","peaksToPeakMap","peakUpdate","peakMapToPeaks","leftIndex","rightIndex","leftHash","rightHash"],"sources":["/Users/takerun/Documents/shigo-gene-main/shigo_gene_minting_dapp/node_modules/merkletreejs/dist/MerkleMountainRange.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleMountainRange = void 0;\nconst buffer_1 = require(\"buffer\");\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n        super();\n        this.root = buffer_1.Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves) {\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */\n    append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n    hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n    hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n    getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for (let i = 255; i > 0; i--) {\n            if ((width & (1 << (i - 1))) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error('invalid bit calculation');\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while (bits > 0) {\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error('received invalid number of peaks');\n        }\n        if (width === 0 && !peaks.length) {\n            return buffer_1.Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n    getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n    getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n    mountainHeight(size) {\n        let height = 1;\n        while (1 << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n    heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n    isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n    getChildren(index) {\n        const left = index - (1 << (this.heightAt(index) - 1));\n        const right = index - 1;\n        if (left === right) {\n            throw new Error('not a parent');\n        }\n        return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n    getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error('not a leaf');\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for (let i = 0; i < peaks.length; i++) {\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while (cursor !== index) {\n            height--;\n            ([left, right] = this.getChildren(cursor));\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error('index is out of range');\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for (let i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error('target not found');\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while (height > 0) {\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                // on the leaf node. Stop climbing down\n                break;\n            }\n            else {\n                // on the parent node. Go left or right\n                ([left, right] = this.getChildren(cursor));\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while (height < path.length) {\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            }\n            else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            }\n            else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error('hashed peak is invalid');\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            }\n            else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error('invalid number of peaks');\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for (let i = 0; i < 32; i++) {\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error('invalid number of peaks');\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            }\n            else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    }\n                    else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                }\n                else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for (let i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n    _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}